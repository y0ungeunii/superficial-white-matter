#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Solves Laplace equation over the domain of white matter.

Using grey matter as the source and ventricles as the sink.
Inputs are expected to be Free/FastSurfer aparc+aseg.mgz in .nii.gz format

Parameters
----------
NIFTI  :    str
            Parcellation file generated by Freesurfer/fastsurfre in nii.gz format (from mri/aparc+aseg.mgz).
NIFTI  :    str
            Output laplacian file path (nii.gz)

Returns
-------
NIFTI
    Laplacian image (nii.gz)

Usage
-----
laplace_solver.py aparc+aseg.nii.gz laplace-wm.nii.gz

Created on October 2023

@author: Jordan DeKraker
code from https://github.com/khanlab/hippunfold/blob/master/hippunfold/workflow/scripts/laplace_coords.py

"""

import nibabel as nib
import numpy as np
import skfmm
from scipy.ndimage import binary_dilation
from astropy.convolution import convolve as nan_convolve
import sys
from time import time


def _get_bounding_box(mask, padding=1):
    """Get tight bounding box around mask with padding."""
    coords = np.where(mask)
    if len(coords[0]) == 0:
        return (0, 0, 0), mask.shape
    
    min_coords = np.maximum(0, [np.min(c) - padding for c in coords])
    max_coords = np.minimum(mask.shape, [np.max(c) + padding + 1 for c in coords])
    
    return tuple(min_coords), tuple(max_coords)


def _crop(x, min_bbox, max_bbox):
    return x[min_bbox[0]:max_bbox[0], min_bbox[1]:max_bbox[1], min_bbox[2]:max_bbox[2]]


def laplace(init_coords, fg, source, sink, kernelSize=3, convergence_threshold=1e-4, max_iters=1000):
    """
    Solve Laplace equation using iterative convolution.
    
    Parameters:
    -----------
    init_coords : ndarray
        Initial solution coordinates
    fg : ndarray (boolean)
        Foreground mask
    source : ndarray (boolean)
        Source mask (boundary condition = 0)
    sink : ndarray (boolean)
        Sink mask (boundary condition = 1)
    kernelSize : int, default=3
        Size of convolution kernel
    convergence_threshold : float, default=1e-4
        Threshold for convergence
    max_iters : int, default=1000
        Maximum number of iterations
    
    Returns:
    --------
    ndarray
        Solution to the Laplace equation
    """
    hl = np.ones([kernelSize, kernelSize, kernelSize])
    hl = hl / np.sum(hl)

    # initialize coords
    coords = np.zeros(init_coords.shape)
    coords[fg] = init_coords[fg]
    coords[source] = 0
    coords[sink] = 1

    print('initialized solution')

    # iterate until the solution doesn't change anymore (or reach max iters)
    for i in range(max_iters):

        upd_coords = nan_convolve(coords, hl, fill_value=np.nan, preserve_nan=True)

        upd_coords[source] = 0
        upd_coords[sink] = 1

        # check difference between last
        diff_coords = coords[fg] - upd_coords[fg]
        diff_coords[np.isnan(diff_coords)] = 0
        ssd = (diff_coords * diff_coords).sum(axis=None)
        print(f'itaration {i}, convergence: {ssd}')
        if ssd < convergence_threshold:
            break
        coords = upd_coords

    return coords


def solve_laplace(
    in_seg,
    out_laplace,
    convergence_threshold=1e-4,
    max_iters=1000,
    kernelSize=3,
    alpha=0.1,
    fg_labels=[41, 2],
    src_labels=np.concatenate((np.arange(1000, 2999), [0])),
    verbose=True
):
    """Solve Laplace equation."""
    total_start = time()
    
    if verbose:
        print("Starting Laplace solver")
    
    # load data
    lbl_nib = nib.load(in_seg)
    lbl = np.asarray(lbl_nib.dataobj, dtype=np.int16)  # Use int16 to save memory
    
    if verbose:
        print(f"Loaded data: {time() - total_start:.2f}s")
    
    # initialize foreground , source, and sink
    fg = np.isin(lbl, fg_labels)
    fg = binary_dilation(fg)  # dilate to make sure we always "catch" neighbouring surfaces in our gradient
    source = np.isin(lbl, src_labels)
    source = source & ~fg  # Remove overlap with foreground
    sink = ~(fg | source)
    
    if verbose:
        print(f"Created masks: {time() - total_start:.2f}s")
        print(f"Foreground: {np.sum(fg)} voxels")
        print(f"Source: {np.sum(source)} voxels") 
        print(f"Sink: {np.sum(sink)} voxels")
    
    # initialize solution with fast marching
    # fast march forward
    phi = np.ones_like(lbl, dtype=np.float32)
    phi[source] = 0.0
    mask = ~(fg | source)
    phi_masked = np.ma.MaskedArray(phi, mask)
    forward = skfmm.travel_time(phi_masked, np.ones_like(lbl, dtype=np.float32))
    init_coords = forward.data
    init_coords = init_coords - np.min(init_coords)
    init_coords = init_coords / np.max(init_coords)
    init_coords[fg] = 0
    
    if verbose:
        print(f"Fast marching: {time() - total_start:.2f}s")
    
    # Work on cropped labelmap
    min_bbox, max_bbox = _get_bounding_box(fg, padding=kernelSize)
    
    solve_start = time()
    
    cropped_coords = laplace(
        _crop(init_coords, min_bbox, max_bbox),
        _crop(fg, min_bbox, max_bbox),
        _crop(source, min_bbox, max_bbox),
        _crop(sink, min_bbox, max_bbox),
        kernelSize=kernelSize,
        convergence_threshold=convergence_threshold,
        max_iters=max_iters
    )
    
    if verbose:
        print(f"Solved Laplace equation: {time() - solve_start:.2f}s")
    
    # Back to original size
    coords = np.zeros_like(init_coords, dtype=np.float32)
    coords[min_bbox[0]:max_bbox[0], min_bbox[1]:max_bbox[1], min_bbox[2]:max_bbox[2]] = cropped_coords
    coords[source] = 0
    coords[sink] = 1
    
    coords = coords * (1 - alpha) + (init_coords * alpha)
    
    # save file
    if verbose:
        print('saving')
    coords_nib = nib.Nifti1Image(coords, lbl_nib.affine, lbl_nib.header)
    coords_nib.set_data_dtype(np.float32)
    nib.save(coords_nib, out_laplace)
    
    if verbose:
        print(f"Total time: {time() - total_start:.2f}s")


if __name__ == "__main__":
    in_seg = sys.argv[1]
    out_laplace = sys.argv[2]
    solve_laplace(in_seg, out_laplace)
